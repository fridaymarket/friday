import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Overview/数据流" />

# 数据流

`@friday/async`的数据流能力，抛弃了原有的redux，全面拥抱hooks, 同时还支持纯函数的async能力。


## Api 聚合

`@friday/async`提供了`createGetApi createPostApi`方便快速生成api。

## `createGetApi/createPostApi<Params, Data>({url: ''}: AxiosConfig)`
`createGetApi`和`createPostApi`相同，都需要传入`axiosconfig`生成一个`api`， 
`Params`和`Data`分别为该api的参数和返回值类型，在`dispatchAsync`和`useRequest`会自动推导`

```css dark
// 生成一个get api
const getUserInfo = createGetApi<{id: number}, {id: number, name: string}>({url: '/userInfo'})
// post api
const deleteUser = createPostApi<{id: number}, {id: number, name: string}>({url: '/delete/user'})
```


## 数据流分发

## useRequest<Params, Data>(service, config): BaseResult<Params, Data> | PaginationResult<Params, Data>
注意⚠️： `useRequest`使用于React.FC场景下，`useRequest ` 只接收`createGetApi`生成的api
生成的api。

useRequest 接收两个参数，
- `service`接收`createGetApi`生成的api
- `config` 接收如下参数

```css dark
interface ConfigInterface<Data = any, Error = any, Fn extends fetcherFn<Data> = fetcherFn<Data>> {
	// 错误重试时间间隔
	errorRetryInterval?: number;
	// 次数
	errorRetryCount?: number;
	// 超时
	loadingTimeout?: number;
	// 获取焦点触发时间间隔
	focusThrottleInterval?: number;
	// 删除缓存数据
	dedupingInterval?: number;
	// 更新缓存数据
	refreshInterval?: number;
	// 是否更新缓存fetcher
	refreshWhenHidden?: boolean;
	// 离线更新
	refreshWhenOffline?: boolean;
	// 页面激活重新拉数据
	revalidateOnFocus?: boolean;
	// 页面激活重新拉数据
	revalidateOnMount?: boolean;
	revalidateOnReconnect?: boolean;
	// 错误重试
	shouldRetryOnError?: boolean;
	// 自定义请求器，已提供全局中间件
	fetcher?: Fn;
	// suspense 
	suspense?: boolean;
	// 默认数据，无需使用
	initialData?: Data;
	// 网络是否在线
	isOnline?: () => boolean;
	// 窗口是否激活
	isDocumentVisible?: () => boolean;
	// 慢请求
	onLoadingSlow?: (key: string, config: ConfigInterface<Data, Error>) => void;
	// 请求成功callback
	onSuccess?: (data: Data, key: string, config: ConfigInterface<Data, Error>) => void;
	// 请求失败callback
	onError?: (err: Error, key: string, config: ConfigInterface<Data, Error>) => void;
	onErrorRetry?: (err: Error, key: string, config: ConfigInterface<Data, Error>, revalidate: revalidateType, revalidateOpts: RevalidateOptionInterface) => void;
	compare?: (a: Data | undefined, b: Data | undefined) => boolean;
	// 分页请求，多两个参数
	defaultPageSize?: number
	// 是否使用分页
	paginated?: boolean
	// 使用postservice的时候，需要传入该参数.
	// tip: 请尽量避免在useRequest使用post，该配置只是为了兼容旧业务做的后门
	biReuqest?: boolean

	// 下拉加载更多，和paginated 自选一个，默认分页
	loadMore?: boolean
}
```
`useRequest`的返回值有三种

##### BaseResult<Params, Data> 
默认返回值
```css dark

export declare type responseInterface<Data, Error> = {
    data?: Data;
    error?: Error;
    revalidate: () => Promise<boolean>;
    mutate: (data?: Data | Promise<Data> | mutateCallback<Data>, shouldRevalidate?: boolean) => Promise<Data | undefined>;
    isValidating: boolean;
};

export interface BaseResult<Params = any, Data = any> extends responseInterface<Data> { 
	params: Params | undefined
	dataArray: Data[]
	dataJson: Data
	responseBlob: any
	responseArray: Response<Data[]>
	responseJson: Response<Data>
}

```

##### PaginationResult<Params, Data> 分页请求
当`config`设置了 `paginated`之后,返回值为`PaginationResult`
```css dark
export interface PaginationResult<Params = any, Data = any> extends BaseResult<Params, Data> {
	params: PaginationParams<Params>
	pagination: PaginationConfig
	tableProps: {
		pagination: PaginationConfig
		loading: boolean
		onChange: (pagination: PaginationConfig) => void;
		dataSource: Data[]
		[key: string]: any;
	}
	noMore?: boolean;
	loadMore: () => any
	dataArray: Data[]
	dataJson: Data
	responseArray: PaginationResponse<Data[]>
	responseJson: PaginationResponse<Data>
}
分页请求的返回值，兼容了`Antd`的`Table`，在如下示例中，将展示如何使用

```

##### LoadMoreResult<Params = any, Data = any> 加载更多（分页）
当`config`设置了 `loadMore`之后,返回值为`LoadMoreResult`，`loadMore`和`paginated`互斥，设置一个就行

```css dark
export interface LoadMoreResult<Params = any, Data = any> extends BaseResult<Params, Data> {
	params: PaginationParams<Params>
	noMore?: boolean;
	onLoadMore: () => any
	dataArray: Data[]
	dataJson: Data
	// list 数据获取的数据汇总， dataArray为当前页数的数据
	list: Data[]
	responseArray: PaginationResponse<Data[]>
	responseJson: PaginationResponse<Data>
}

```

#### 发起一个useRequest请求

```css dark

import { createGetApi, useRequest } from '@friday/async'

const getUserInfo = createGetApi<{id: number}, {id: number, name: string}>({url: '/userInfo'})

const response = useRequest(getUserInfo(params))

```

#### 发起一个useRequest分页请求, 并使用antd table中

```css dark
import { createGetApi, useRequest } from '@friday/async'

import { Table } from 'Antd'

const getList = createGetApi<{id: number}, {id: number, name: string}[]>({url: '/list'})

const { pagination, tableProps } = useRequest(getList(params), {
	paginated: true
})

<Table 
	{...tableProps}
	或者只使用分页
	pagination={pagination}
>
```

#### 发起一个useRequest加载更多请求，加载更多一般适用于滚动数据展示

```css dark
import { createGetApi, useRequest } from '@friday/async'

import { Button } from 'Antd'

const getList = createGetApi<{id: number}, {id: number, name: string}[]>({url: '/list'})

const App = () => {

	const { list, onLoadMore } = useRequest(getList(params), {
		loadMore: true
	})
	return (
		<div>
			{list}
			<Button onClick={onLoadMore}>onLoadMore</Button>
		</div>
	)
}
```

## dispatchAsync<Parmas, Data>(service): BaseResult<Params, Data>
`dispatchAsync`同时支持`get|post service`，返回`BaseResult`
<p>`dispatchAsync`  返回一个promise</p>

Friday之前，async post数据通过redux方式管理，之后，我们保留了async post，但是去除了redux。

#### 使用`dispatchAsync`发起一个post/get请求

```css dark
import { createPostApi, dispatchAsync } from '@friday/async'

const deleteUser = createPostApi<{id: number}, {id: number, name: string}>({url: '/delete/user'})

const deleteController = async () => {
	const responst = await dispatchAsync(deleteUser({id: 2}))
}
```

#### 使用`dispatchAsync`发起一个post/get下载（responseType： blob）
当`createPostApi`设置`responseType` 为 `blob` 时，`dispatchAsync`将返回流, 流将通过`responseBlob`字段返回。
```css dark
import { createPostApi, dispatchAsync } from '@friday/async'

const deleteUser = createPostApi<{id: number}, {id: number, name: string}>({url: '/delete/user', responseType: 'blob'})

const deleteController = async () => {
	const { responseBlob } = await dispatchAsync(deleteUser({id: 2}))

	const downInstance = new DownloadService()
	downInstance.download(responseBlob, '报表.xlsx')
}

```
