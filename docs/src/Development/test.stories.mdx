import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Development/单元测试" />

在Friday框架中，我们使用`jest` + `React Testing Library`来进行测试。

#### 在Friday中开启测试:

```css dark
yarn test:watch

```

## Jest 基础知识（https://jestjs.io/docs/zh-Hans/mock-functions）

 - test/it ：用于描述测试本身，其包含两个参数，第一个是该测试的描述，第二个是执行测试的函数。
 - expect ：表示测试需要通过的条件，它将接收到的参数与 matcher  进行比较。
 - matcher ：一个希望到达预期条件的函数，称其为匹配器。
 - render ：用于渲染给定组件的方法。
```css dark
import React from "react";
import { render } from "@testing-library/react";
import App from "./App";

test("should take a snapshot", () => {
  const { asFragment } = render(<App />);

  expect(asFragment(<App />)).toMatchSnapshot();
});

```

如上所示，我们使用`test`来描述一个测试，然后使用 `render`  方法来显示 `App` 这个组件，
同时还期待的是 `asFragment(<App />)`  的结果与 `toMatchSnapshot()`  这个 `matcher`  匹配（由 jest 提供的匹配器）。

`jest`官方文档十分详细，再次不多叙述，自行查阅官方文档

### 关于`React Testing Library`（https://testing-library.com/）
--- 

⚠️注意： `React Testing Library` 是一个 `DOM` 测试库，这意味着它并不会直接处理渲染的 `React` 组件实例，而是处理 DOM 元素以及它们在实际用户面前的行为。

`React Testing Library` 是用于测试 React 组件的非常便捷的解决方案。 它在 `react-dom`  和 `react-dom/test-utils ` 之上提供了轻量且实用的 API

测试一个 React 组件，大致分成这几个步骤：
- 在 DOM 中渲染组件
- 验证组件初始化渲染出的 DOM
- 模拟用户与组件的交互，触发 DOM 事件
- 验证组件重新渲染后的 DOM

以下将根据常用场景提供多个示例:
--- 

#### 创建测试快照 

快照使我们可以保存给定组件的快照。 当你对组件进行一些更新或重构，希望获取或比较更改时.

```css dark
import React from "react"
import { render, cleanup } from "@testing-library/react"
import App from "./App"

afterEach(cleanup);

test("should take a snapshot", () => {
  const { asFragment } = render(<App />);

  expect(asFragment(<App />)).toMatchSnapshot();
})

```

`cleanup`  方法将作为参数传递给 `afterEach`，目的是在每个测试完成后清除所有内容，以避免内存泄漏。在每个测试文件中，都应该使用该设置。
使用`yarn run test`之后它将创建一个新文件夹 `__snapshots__`和及其目录下新建一个 `App.test.js.snap`文件,如果现在你对 App.js  进行更改，则测试将失败，因为快照将不再符合条件。要使其通过，只需按键盘上的 `u ` 健即可对其进行更新

#### 测试 DOM 元素

- `TestElements.js`: 
```css dark
import React from "react";

const TestElements = () => {
  const [counter, setCounter] = React.useState(0);

  return (
    <>
      <h1 data-testid="counter">{counter}</h1>
      <button data-testid="button-up" onClick={() => setCounter(counter + 1)}>Up</button>
      <button
        disabled
        data-testid="button-down"
        onClick={() => setCounter(counter - 1)}
      >
        Down
      </button>
    </>
  );
};

export default TestElements;

```

##### 测试计数器（counter）是否等于 0
- `TestElements.test.js`

```css dark
import React from "react";
import { render, cleanup } from "@testing-library/react"
import TestElements from "./TestElements"

afterEach(cleanup);

it("should equal to 0", () => {
  const { container, getByTestId,  } = render(<TestElements />);
  expect(getByTestId("counter")).toHaveTextContent(0);
});

```
我们现在使用 `getByTestId`  进行 dom 元素的获取，然后检查该元素的文本内容是否为 0, 我们也可以使用`container`,`container`将拿到React组件
渲染的dom元素，操作手段就是原生js的方法如`container.getElementsByClassName`等方法。


#### 测试事件

```css dark
import React from "react";
import { render, cleanup, fireEvent } from "@testing-library/react";
import TestEvents from "./TestEvents";

afterEach(cleanup);

it("increments counter", () => {
  const { getByTestId, container } = render(<TestEvents />);

  // 如果TestEvents里面有class 也可以使用container来找元素
  // fireEvent.click(container.getElementsByClassName("className"));

  fireEvent.click(getByTestId("button-up"));

  expect(getByTestId("counter")).toHaveTextContent("1")
})

```

#### 测试异步操作

异步操作需要花费一些时间才能完成。它可以是 HTTP 请求，计时器等。

```css dark
import React from "react";

const TestAsync = () => {
  const [counter, setCounter] = React.useState(0);

  const delayCount = () =>
    setTimeout(() => {
      setCounter(counter + 1);
    }, 500);

  return (
    <>
      <h1 data-testid="counter">{counter}</h1>
      <button data-testid="button-up" onClick={delayCount}>
        Up
      </button>
      <button data-testid="button-down" onClick={() => setCounter(counter - 1)}>
        Down
      </button>
    </>
  );
};

export default TestAsync

```
在这里，我们使用 `setTimeout()``  模拟异步。
我们来测试下`TestAsync`

```css dark
import React from "react";
import {
  render,
  cleanup,
  fireEvent,
  waitForElement,
} from "@testing-library/react"
import TestAsync from "./TestAsync";

afterEach(cleanup);

test("increments counter after 0.5s", async () => {
  const { getByTestId, getByText } = render(<TestAsync />);

  fireEvent.click(getByTestId("button-up"));
  // 等待元素出现
  const counter = await waitForElement(() => getByText("1"));

  expect(counter).toHaveTextContent("1");
});

```
可以看到与`测试事件`不同的是，`test` 的第二个参数我们使用了`async/await`，因为异步事件需要一定的时间来触发
并且我们使用`waitForElement`来等待异步事件的完成。

#### 测试包含@friday/async 的组件 （mock库）

我们来写伪代码来观察下，包含@friday/async的组件是什么样的,
```css dark
import React from 'react'
import { useRequest } from '@friday/async'

const FridayPanel = () => {

	const { dataJson } = useRequest(service())

	return {
		<div className='datajson'>JSON.stringify({dataJson})</div>
	}
}
```
上面的组件我们可以看到`FridayPanel`包含了`useRequest`的异步事件，我们在测试一个组件的时候，有时候只需要组件内部的一些操作只需要返回结果让我们完成渲染流程。
在这种情况下我们需要mock一些不关心的函数，如上组件我们需要mock `@friday/async`库。

```css dark
import React from 'react'
import {useRequest} from '@friday/async'
import { render, cleanup, fireEvent, waitFor } from '@testing-library/react';
import useRequest from '.'

jest.mock("@friday/async")

afterEach(cleanup)

test('useRequest', async () => {
	const defaultJson = { id: 'id_tset', name: 'name' }
	(useRequest as any).mockImplementation(() => {
		return {
			dataJson: defaultJson
		}
	})

	const { container } = render(<FridayPanel/>)
    // 等待元素出现
	await waitFor(() => {
		expect(container.getElementsByClassName("datajson")[0]).toBe(JSON.stringify({dataJson}))
	})
})
```
可以看到，我们mock了`@friday/async`让`useRequest`返回了一个我们设置的值，因为是异步操作，最后使用`waitFor`来等待异步事件的完成，并进行对比。
mock库只是mock中的一种，有时候一些关联了业务逻辑的函数也需要mock，我们可以使用`jest.mock`来mock实现
```css dark
// foo.js
module.exports = function() {
  // some implementation;
};

// test.js
jest.mock('../foo'); // this happens automatically with automocking
const foo = require('../foo');

// foo is a mock function
foo.mockImplementation(() => 42);
foo();
// > 42
```
mock实现和mock库的原理类似，mock还有很多其他场景，具体自行查阅文档

#### 测试自定义hooks函数
`React Testing Library`提供了`@testing-library/react-hooks`库来测试hooks，`@testing-library/react-hooks`中有两个函数是重点
--- 

##### renderHook(callback[, options]) 渲染一个用于测试的组件，这个组件会调用包含 hook 的callback
参数说明：

- callback (() => any) - 测试组件每次渲染时调用的方法。这个方法应该调用需要测试的 hook。
- options (object) - 配置对象。有以下配置项：
	- initialProps (object) - 传递给callback函数的初始值
	- wrapper (componenet) - pass a React Component as the wrapper option to have it rendered around the inner element. This is most useful for creating reusable custom render functions for common data providers
返回值：

- result (object)
  - current (any) - callback函数返回的值
  - error (Error) - callback函数抛出的错误。
  - waitForNextUpdate (function) - 返回一个 Promise，它在下次组件渲染时结束。一般用于由于异步操作导致状态更新的情况。
  - rerender (function([newProps])) - 重新渲染测试组件的方法。重新渲染测试组件时，会再次调用callback函数。如果指定了newProps，则会将newProps传递给callback。
  - unmount (function()) - 卸载测试组件。一般用于触发useEffect hook 的清除动作
##### act(callback) 
与react-test-renderer 的 act()方法是一样的作用。

为断言准备一个组件，包裹要渲染的代码并在调用act()时执行更新。这会使得测试更接近 React 在浏览器中的工作方式。


下面我们来测试个hooks
```css dark
import { useState, useCallback } from 'react';

function useCounter() {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => setCount((x) => x + 1), []);
  const decrement = useCallback(() => setCount((x) => x - 1), []);

  return { count, increment, decrement };
}

export default useCounter;

```

```css dark
import { renderHook, act } from '@testing-library/react-hooks';
import useCounter from './useCounter';

it('增加计数', () => {
  // 初始化useCounter。
  // 相当于创建了一个使用useCounter的组件。
  const { result } = renderHook(() => useCounter());

  // 调用useCounter hook的`increment()`。
  // 记住：千万别丢了`act`。
  // 必须在`act`中执行hook中的方法
  act(() => result.current.increment());

  // 期望count从0增加到了1
  expect(result.current.count).toBe(1);
});

```
